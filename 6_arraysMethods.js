// Методы работы с массивами

//===============================================================================================//

// Перебор элементов массива
// .forEach()

// Добавление/удаление элементов
// .push() *
// .pop() *
// .unshift() *
// .shift() *
// .splice() *
// .slice()
// .concat()

// Преобразование массива
// .map()
// .sort() *
// .reverse() *
// .join()
// .reduce()
// .flat()
// .flatMap()

// Поиск по массиву
// .indexOf()
// .lastIndexOf()
// .includes()
// .find()
// .findIndex()
// .filter()
// .some()
// .every()

// * - Изменяют исходный массив

// При использовании отдавать приоритет тем, которые не изм. исх. массив

//===============================================================================================//

// Нахождение чисел, кратные 3 с помощью цикла

// const getSpecialNumbers = numbers => {
//     let specialNumbers = []
//     for (let i = 0; i < numbers.length; i++) {
//         if (numbers[i] % 3 === 0) {
//             specialNumbers.push(numbers[i])
//         }
//     }
//     return specialNumbers
// }

// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(getSpecialNumbers(arr));

//===============================================================================================//

/* 
Метод .forEach() используется для выполнения функции один раз для каждого элемента массива. 
Он не изменяет оригинальный массив и не возвращает новое значение.
Метод forEach() автоматически встроен в любой массив.

array.forEach(callback(currentValue, index, array), thisArg);
    callback: Функция, которая будет выполнена для каждого элемента массива. Она принимает три аргумента:
        currentValue: Текущий обрабатываемый элемент массива.
        index (необязательно): Индекс текущего элемента.
        array (необязательно): Массив, по которому выполняется обход.
    thisArg (необязательно): Значение, используемое в качестве this при выполнении функции callback.
Особенности:
    Метод forEach не возвращает новое значение, он просто выполняет указанную функцию для каждого элемента массива.
    Нельзя прервать выполнение метода forEach с помощью break или return. 
    Если нужно прервать выполнение, лучше использовать цикл for или метод some.
*/ 


//Примеры:

// Нахождение чисел, кратные 3 с помощью метода forEach()

// Первый способ
// const getSpecialNumbers = numbers => {
//     let specialNumbers = []

//     const checkIfSpecialNumber = num => {
//         if(num % 3 === 0) {
//             specialNumbers.push(num)
//         }
//     }

//     numbers.forEach(checkIfSpecialNumber)

//     return specialNumbers
// }

// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(getSpecialNumbers(arr));


// Второй способ
// const getSpecialNumbers = numbers => {
//     let specialNumbers = []

//     numbers.forEach(num => {
//         if(num % 3 === 0) {
//             specialNumbers.push(num)
//         }
//     })

//     return specialNumbers
// }

// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(getSpecialNumbers(arr));

//===============================================================================================//

// Метод .filter()
/*
Метод массива .filter() позволяет получить новый массив, отфильтровав элементы с помощью переданной колбэк-функции. 
Колбэк-функция будет вызвана для каждого элемента массива и по результату функции примет решение включать этот элемент в 
новый массив или нет.
Аналогично методу .forEach(), методу .filter() необходимо передать аргументом функцию. 
Главное отличие — функция должна возвращать boolean, т. е. результатом должен быть true или false. 
Такие функции называют предикатами.

array.filter(callback(element, index, array), thisArg);
    callback: Функция, которая будет выполнена для каждого элемента массива. Она принимает три аргумента:
        element: Текущий обрабатываемый элемент массива.
        index (необязательно): Индекс текущего элемента.
        array (необязательно): Массив, по которому выполняется обход.
    thisArg (необязательно): Значение, используемое в качестве this при выполнении функции callback.


Функция, которую мы передаём в метод .filter(), принимает три параметра:
    item — элемент массива в текущей итерации;
    index — индекс текущего элемента;
    arr — сам массив, который мы перебираем.

Особенности
Метод filter возвращает новый массив, содержащий элементы, которые прошли проверку в функции callback.
Если ни один элемент не прошел проверку, метод filter вернет пустой массив.

*/

// Первый вариант
// const getSpecialNumbers = numbers => {
//     const result = numbers.filter(num => {
//         if(num % 3 === 0) {
//             return true
//         }
//         return false
//     })
//     return result
// }

// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(getSpecialNumbers(arr));

// Второй вариант
// const getSpecialNumbers = numbers => {
//     return numbers.filter(num => num % 3 === 0)
// }
// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(getSpecialNumbers(arr))


//===============================================================================================//

// Метод .sort()

/*
Метод sort() используется для сортировки элементов массива на месте и возвращает отсортированный массив. 
По умолчанию элементы сортируются как строки в порядке возрастания.

Метод имеет только один опциональный параметр — функцию-компаратор sort(compareFn).

В функцию-компаратор передаются два аргумента a и b. Результат сравнения возвращаемого значения из 
функции с 0 определяет порядок элементов:
    значение меньше 0 означает, что элемент a меньше, чем элемент b;
    значение больше 0 означает, что элемент a больше, чем элемент b;
    значение равно 0 означает, что элементы равны.
Все элементы массива со значением undefined после сортировки попадут в конец массива. 
Для этих элементов не будет вызываться функция compareFn().
*/

// const sortArray = numbers => {
//     // Создание коппии массива, чтобы не изменять исходный
//     // let copy = [...numbers]
//     // Коппирование всех элементов индексов
//     let copy = numbers.slice()
//     copy.sort((a, b) => a - b)

//     return copy
// }

// const arr = [2, 4, 1, 5, 21, 18]
// console.log(sortArray(arr));

// console.log(arr);


//===============================================================================================//

// Метод .reduce()

/*
Метод массива reduce() позволяет превратить массив в любое другое значение с помощью переданной функции-колбэка и 
начального значения. Функция-колбэк будет вызвана для каждого элемента массива, и всегда должна возвращать результат.

Метод reduce() принимает два параметра: функцию-колбэк и начальное значение для аккумулятора.

Сама функция-колбэк может принимать четыре параметра:
    acc — текущее значение аккумулятора;
    item — элемент массива в текущей итерации;
    index — индекс текущего элемента;
    arr — сам массив, который мы перебираем.

*/ 

// [1, 2, 3, 4, 5] сложение всех чисел в масссиве
// const arr = [1, 2, 3, 4, 5]
// const sum = arr.reduce((acc, num) => acc + num, 0)
// console.log(sum);

/*
1: 0, 1 => 1
2: 1, 2 => 3
3: 3, 3 => 6
4: 6, 4 => 10
5: 10, 5 => 15
*/ 

//===============================================================================================//

// Метод concat()

// Метод concat() возвращает новый массив, содержащий все элементы исходного массива.
// [1, [2, 3, 4], 5, [6]] => [1, 2, 3, 4, 5, 6]

// const flatArray = arr => 
//     arr.reduce((acc, elem) => acc.concat(elem), [])

// const array = [1, [2, 3, 4], 5, [6]]
// console.log(flatArray(array));

// Не поддерживается во многих браузерах
// const array = [1, [2, 3, 4], 5, [6]].flat()
// console.log(array);

//===============================================================================================//

// Метод slice()

// Метод slice() возвращает новый массив, содержащий часть элементов исходного массива
// const arr = [1, 2, 3, 4, 5, 6, 7, 8 ,9].slice(3, 8)
// console.log(arr)

//===============================================================================================//

// Метод splice()

// Метод splice() изменяет содержимое массива, добавляя или удаляя элементы в указанном месте массива.

// Удаление элементов
// const tasks = [
//     'Проверить тесты',
//     'Выполнить код-ревью',
//     'Поработать',
//     'Вкатиться в айтишку',
//     'Приготовить еду',
//     'Подготовить доклад',
//     'Обновить бэклог'
// ]
//   tasks.splice(1, 4)
//   console.log(tasks)


// Добавление элементов. Достаточно установить deleteCount в 0
// let arr = ["Я", "изучаю", "JavaScript"]

// // с индекса 2
// // удалить 0 элементов
// // вставить "сложный", "язык"
// arr.splice(2, 0, "сложный", "язык")

// console.log(arr) // "Я", "изучаю", "сложный", "язык", "JavaScript"

//===============================================================================================//

// Метод indexOf() и includes()

// Метод indexOf() возвращает индекс первого вхождения элемента в массив.
// Метод includes() возвращает true, если элемент есть в массиве, и false, если элемента нет в массиве.

// indexOf() Возвращает индекс элемента. В противном случае -1.
// includes() Проверяет, входит ли элемент в массив или нет

// Примеры:
// const arr = ['Bob', 'John', 'Tom'].indexOf('Tom')
// console.log(arr)


// const getMessagesForPassedStudents = (allStudents, failedStudents) => {
//     const passedStudents = allStudents
//         // .filter(name => !(failedStudents.indexOf(name) !== -1))
//         // .filter(name => failedStudents.indexOf(name) === -1)
//     return passedStudents
// }

// const allStudents = ['Ann', 'Tom', 'Bob', 'Kate']
// const failedStudents = ['Tom', 'Bob']

// console.log(getMessagesForPassedStudents(allStudents, failedStudents))


// const getMessagesForPassedStudents = (allStudents, failedStudents) => {
//     const passedStudents = allStudents
//         .filter(name => !failedStudents.includes(name))
//     return passedStudents
// }

// const allStudents = ['Ann', 'Tom', 'Bob', 'Kate']
// const failedStudents = ['Tom', 'Bob']

// console.log(getMessagesForPassedStudents(allStudents, failedStudents))

//===============================================================================================//

// Метод map()

// Применяется к каждому эл. массива и возвращает новый массив(в котором каждый элемент — результат вызова callback-функции для каждого).

// const getMessagesForPassedStudents = (allStudents, failedStudents) => {
//     return allStudents
//         .filter(name => !failedStudents.includes(name))
//         .map(name => `Hello, ${name}!`)
// }

// const allStudents = ['Ann', 'Tom', 'Bob', 'Kate']
// const failedStudents = ['Tom', 'Bob']

// console.log(getMessagesForPassedStudents(allStudents, failedStudents))

//===============================================================================================//

















 




























































































// 📌 Методы массивов в JavaScript

// Методы работы с массивами

//===============================================================================================//

// 1️⃣ Перебор элементов массива
// .forEach()
// const arr = [1, 2, 3];
// arr.forEach(num => console.log(num)); // 1, 2, 3 (перебор элементов)


// 2️⃣ Добавление/удаление элементов
// const numbers = [1, 2, 3];

// .push() *
//  numbers.push(4);  // [1, 2, 3, 4] (добавляет в конец) 

// .pop() *
//  numbers.pop();    // [1, 2] (удаляет последний) 

// .unshift() *
//  numbers.unshift(0); // [0, 1, 2, 3] (добавляет в начало) 

// .shift() *
//  numbers.shift();  // [2, 3] (удаляет первый)

// .splice() *
//  numbers.splice(1, 1, 99); // [1, 99, 3] (удаляет и добавляет по индексу) 

// .slice()
//  const sliced = numbers.slice(1, 2); // [2] (копирует часть массива)

// .concat()
//  const combined = numbers.concat([4, 5]); // [1, 2, 3, 4, 5] (объединяет массивы)


// 3️⃣ Преобразование массива
// const numbers = [1, 2, 3]

// .map()
//  const doubled = numbers.map(num => num * 2); // [2, 4, 6] (преобразует элементы)

// .sort() *
//  const sorted = [3, 1, 2].sort(); // [1, 2, 3] (сортирует) 

// .reverse() *
//  const reversed = [1, 2, 3].reverse(); // [3, 2, 1] (переворачивает) 

// .join()
// const joined = numbers.join('-'); // "1-2-3" (объединяет в строку)

// .reduce()
// const sum = numbers.reduce((acc, num) => acc + num, 0); // 6 (сворачивает массив)

// .flat()
// const flatArray = [1, [2, 3], [4, 5]].flat(); // [1, 2, 3, 4, 5] (разглаживает вложенные массивы)

// .flatMap()
// const resultingArray = numbers.flatMap((x) => [x ** 2]); // [ 1, 4, 9, 16, 25 ](сначала вызывает функцию к каждому элементу в массиве как в методе map(), 
// а затем сокращает вложенность массива как в методе flat() на 1 уровень.)


// 4️⃣ Поиск по массиву
// const numbers = [1, 2, 3]

// .indexOf()
// numbers.indexOf(1) // 0(индекс найденного элемента) -1(если ничего не нашлось)

// .lastIndexOf()
// ведёт пойиск с конца массива

// .includes()
//  const hasTwo = numbers.includes(2); // true (проверяет наличие)

// .find()
//  const found = numbers.find(num => num > 1); // 2 (возвращает первый найденный)

// .findIndex()


// .filter()
//  const filtered = numbers.filter(num => num > 1); // [2, 3] (фильтрует)

// .some()
//  const someGreaterThanTwo = numbers.some(num => num > 2); // true (хотя бы один)

// .every()
//  const allGreaterThanZero = numbers.every(num => num > 0); // true (все соответствуют)


// * - Изменяют исходный массив

// При использовании отдавать приоритет тем, которые не изм. исх. массив

//===============================================================================================//
// 🎯 Итог:
// ✅ Методы массивов позволяют изменять, искать и преобразовывать данные.
// ✅ Методы с `*` изменяют исходный массив, поэтому их следует использовать осторожно.
// ✅ Для безопасного изменения массива лучше использовать `.map()`, `.filter()`, `.slice()`, `.concat()`.

// 📌 Нахождение чисел, кратных 3 с помощью цикла

//===============================================================================================//
// 🔹 Классический способ (for)
const getSpecialNumbers = numbers => {
    let specialNumbers = [];
    for (let i = 0; i < numbers.length; i++) {
        if (numbers[i] % 3 === 0) {
            specialNumbers.push(numbers[i]);
        }
    }
    return specialNumbers;
};

let array = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(getSpecialNumbers(array)); // [3, 6, 9]

//===============================================================================================//
// 🔹 Альтернативный способ (forEach)
const getSpecialNumbersForEach = numbers => {
    let specialNumbers = [];
    numbers.forEach(num => {
        if (num % 3 === 0) {
            specialNumbers.push(num);
        }
    });
    return specialNumbers;
};

console.log(getSpecialNumbersForEach(array)); // [3, 6, 9]

//===============================================================================================//
// 🔹 Оптимизированный способ (filter)
const getSpecialNumbersFilter = numbers => numbers.filter(num => num % 3 === 0);

console.log(getSpecialNumbersFilter(array)); // [3, 6, 9]

//===============================================================================================//
// 🎯 Итог:
// ✅ `for` – классический способ, удобен для сложных операций.
// ✅ `forEach` – более читаемый, но требует внешнего массива для хранения результатов.
// ✅ `filter` – самый лаконичный и удобный способ для нахождения элементов по условию.


/* 
📌 Метод .forEach() используется для выполнения функции один раз для каждого элемента массива. 
Он не изменяет оригинальный массив и не возвращает новое значение.
Метод forEach() автоматически встроен в любой массив.

array.forEach(callback(currentValue, index, array), thisArg);
    🔹 callback: Функция, которая будет выполнена для каждого элемента массива. Она принимает три аргумента:
        - currentValue: Текущий обрабатываемый элемент массива.
        - index (необязательно): Индекс текущего элемента.
        - array (необязательно): Массив, по которому выполняется обход.
    🔹 thisArg (необязательно): Значение, используемое в качестве this при выполнении функции callback.

📌 Особенности:
    ✅ Метод forEach не возвращает новое значение, он просто выполняет указанную функцию для каждого элемента массива.
    ✅ Нельзя прервать выполнение метода forEach с помощью break или return. 
    ✅ Если нужно прервать выполнение, лучше использовать цикл for или метод some.
*/

//===============================================================================================//
// 🔹 Пример 1: Вывод элементов массива
const numbersArr = [1, 2, 3, 4, 5];

// numbersArr.forEach(num => console.log(num)); 
// 1
// 2
// 3
// 4
// 5

//===============================================================================================//
// 🔹 Пример 2: Использование индекса
// numbersArr.forEach((num, index) => console.log(`Индекс ${index}: значение ${num}`));
// Индекс 0: значение 1
// Индекс 1: значение 2
// Индекс 2: значение 3
// Индекс 3: значение 4
// Индекс 4: значение 5

//===============================================================================================//
// 🔹 Пример 3: Изменение элементов массива (не рекомендуется)
// numbersArr.forEach((num, index, arr) => arr[index] = num * 2);
// console.log(numbersArr); // [2, 4, 6, 8, 10]

//===============================================================================================//
// 🔹 Пример 4: Использование thisArg
// const obj = {
//     multiplier: 3,
//     multiplyNumbers(arr) {
//         arr.forEach(function(num) {
//             console.log(num * this.multiplier);
//         }, this); // Передаем thisArg
//     }
// };

// obj.multiplyNumbers(numbersArr);
// 3
// 6
// 9
// 12
// 15

//===============================================================================================//
// 🎯 Итог:
// ✅ Метод .forEach() удобен для выполнения действий над каждым элементом массива.
// ✅ Не изменяет оригинальный массив (если не делать этого вручную).
// ✅ Не возвращает новое значение, поэтому для преобразования массива лучше использовать .map().



// 📌 Метод .filter()

//===============================================================================================//
// 🔹 Что делает .filter()
// Метод `.filter()` создает **новый массив**, оставляя только те элементы, которые **соответствуют условию**.

// 📌 Синтаксис:
// array.filter(callback(element, index, array), thisArg);
    // callback: Функция, выполняемая для каждого элемента массива.
    //    element: Текущий обрабатываемый элемент.
    //    index (необязательно): Индекс элемента.
    //    array (необязательно): Сам массив.
    // thisArg (необязательно): Значение для `this` внутри callback-функции.

// 📌 Особенности:
// ✅ Возвращает новый массив.
// ✅ Не изменяет оригинальный массив.
// ✅ Если ни один элемент не соответствует условию, вернет пустой массив [].

//===============================================================================================//
// 🔹 Примеры использования

// 📌 Фильтрация четных чисел
const numbersArray = [10, 15, 20, 25, 30];
const evenNumbers = numbersArray.filter(num => num % 2 === 0);
console.log(evenNumbers); // [10, 20, 30]

// 📌 Фильтрация строк по длине
const words = ["apple", "banana", "kiwi", "pineapple"];
const shortWords = words.filter(word => word.length < 6);
console.log(shortWords); // ["apple", "kiwi"]

// 📌 Фильтрация уникальных значений в массиве объектов
const users = [
    { name: "Alice", age: 25 },
    { name: "Bob", age: 30 },
    { name: "Charlie", age: 25 }
];

const uniqueAges = users.filter((user, index, array) =>
    array.findIndex(u => u.age === user.age) === index
);
console.log(uniqueAges);
/*
[
    { name: "Alice", age: 25 },
    { name: "Bob", age: 30 }
]
*/

//===============================================================================================//
// 🔹 ⚠️ Важно помнить:
// ✅ `.filter()` **не изменяет оригинальный массив**.
// ✅ **Не подходит** для поиска первого подходящего элемента (используйте `.find()`).
// ✅ **Работает с объектами**, но требует осторожности при больших объемах данных.

//===============================================================================================//
// 🎯 Итог:
// ✅ `.filter()` создает новый массив из элементов, прошедших проверку.
// ✅ Не изменяет исходный массив.
// ✅ Возвращает пустой массив, если нет подходящих элементов.



// 📌 Метод .sort()

//===============================================================================================//
// 🔹 Что делает .sort()
// Метод `.sort()` **сортирует элементы массива на месте** и возвращает отсортированный массив.
// По умолчанию элементы сортируются **как строки**, даже если это числа!

// 📌 Синтаксис:
// array.sort(compareFn);
    // compareFn (необязательно): Функция сравнения для точной сортировки.


//===============================================================================================//
// 🔹 Как работает compareFn()
// Функция сравнения принимает два аргумента `a` и `b`, затем:
// ✅ Если `a < b`, возвращает отрицательное число (a идет раньше).
// ✅ Если `a > b`, возвращает положительное число (b идет раньше).
// ✅ Если `a === b`, возвращает `0` (порядок остается неизменным).

//===============================================================================================//
// 🔹 Примеры использования

// 📌 Простой вызов `.sort()` без параметров (НЕ для чисел!)
const wordsArr = ["banana", "apple", "cherry"];
console.log(wordsArr.sort()); // ["apple", "banana", "cherry"]

// 📌 Сортировка чисел по возрастанию (корректный способ)
const arrNumbers = [2, 4, 1, 5, 21, 18];
const sortedNumbers = arrNumbers.slice().sort((a, b) => a - b);
console.log(sortedNumbers); // [1, 2, 4, 5, 18, 21]

// 📌 Сортировка чисел по убыванию
const descendingNumbers = arrNumbers.slice().sort((a, b) => b - a);
console.log(descendingNumbers); // [21, 18, 5, 4, 2, 1]

// 📌 Сортировка массива объектов по возрасту
const usersObj = [
    { name: "Alice", age: 25 },
    { name: "Bob", age: 30 },
    { name: "Charlie", age: 20 }
];

const sortedUsers = usersObj.sort((a, b) => a.age - b.age);
console.log(sortedUsers);
/*
[
    { name: "Charlie", age: 20 },
    { name: "Alice", age: 25 },
    { name: "Bob", age: 30 }
]
*/

//===============================================================================================//
// 🔹 ⚠️ Важно помнить:
// ✅ `.sort()` **изменяет исходный массив**! Используйте `.slice()`, если нужна копия.
// ✅ Работает правильно только с функцией `compareFn`, иначе сортирует числа как строки.
// ✅ **Не подходит для устойчивой сортировки** (сохранения исходного порядка равных элементов).

//===============================================================================================//
// 🎯 Итог:
// ✅ `.sort()` изменяет массив, сортируя элементы.
// ✅ Лучше использовать с `compareFn` для точной сортировки.
// ✅ Будьте осторожны: **изменяет оригинальный массив**.



// 📌 Метод .reduce()

//===============================================================================================//
// 🔹 Что делает .reduce()
// Метод `.reduce()` выполняет **итеративное вычисление** над массивом, превращая его в **одно значение**.

// 📌 Синтаксис:
// array.reduce(callback(acc, item, index, arr), initialValue);
    // acc: Аккумулятор, сохраняющий промежуточный результат.
    // item: Текущий элемент массива.
    // index (необязательно): Индекс текущего элемента.
    // arr (необязательно): Сам массив.
    // initialValue: Начальное значение аккумулятора (рекомендуется задавать!).

// 📌 Особенности:
// ✅ **Не изменяет оригинальный массив**.
// ✅ Если `initialValue` **не задан**, первым значением `acc` будет **первый элемент массива**.

//===============================================================================================//
// 🔹 Примеры использования

// 📌 Сложение всех чисел массива
const numArr = [1, 2, 3, 4, 5];
const sum1 = numArr.reduce((acc, num) => acc + num, 0);
console.log(sum1); // 15

/*
Шаги выполнения:
1: acc = 0, num = 1 => acc = 1
2: acc = 1, num = 2 => acc = 3
3: acc = 3, num = 3 => acc = 6
4: acc = 6, num = 4 => acc = 10
5: acc = 10, num = 5 => acc = 15
*/

// 📌 Получение произведения всех элементов массива
const product = numArr.reduce((acc, num) => acc * num, 1);
console.log(product); // 120

// 📌 Подсчет количества повторений элементов
const fruits = ["apple", "banana", "apple", "orange", "banana", "apple"];
const fruitCount = fruits.reduce((acc, fruit) => {
    acc[fruit] = (acc[fruit] || 0) + 1;
    return acc;
}, {});
console.log(fruitCount); // { apple: 3, banana: 2, orange: 1 }

// 📌 Преобразование массива объектов в сумму значений
const orders = [
    { id: 1, price: 100 },
    { id: 2, price: 200 },
    { id: 3, price: 50 }
];

const totalPrice = orders.reduce((acc, order) => acc + order.price, 0);
console.log(totalPrice); // 350

//===============================================================================================//
// 🔹 ⚠️ Важно помнить:
// ✅ `.reduce()` полезен, когда нужно **одно итоговое значение** (например, сумма, объект, строка).
// ✅ Будьте осторожны, если **не указать `initialValue`** — это может привести к ошибкам!
// ✅ Если массив пуст, но `initialValue` **задано**, `.reduce()` вернет `initialValue`.

//===============================================================================================//
// 🎯 Итог:
// ✅ `.reduce()` превращает массив в **одно значение**.
// ✅ **Не изменяет оригинальный массив**.
// ✅ Рекомендуется **всегда указывать `initialValue`**!



// 📌 Метод .concat()

//===============================================================================================//
// 🔹 Что делает .concat()
// Метод `.concat()` **объединяет два или более массивов** и возвращает **новый массив**.

// 📌 Синтаксис:
// const newArray = array1.concat(array2, array3, ...);
    // array1: Исходный массив.
    // array2, array3, ...: Массивы или значения, которые нужно добавить.

// 📌 Особенности:
// ✅ **Не изменяет** оригинальный массив, а создает новый.
// ✅ Можно объединять **как массивы, так и отдельные элементы**.

//===============================================================================================//
// 🔹 Примеры использования

// 📌 Объединение двух массивов
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const result = arr1.concat(arr2);
console.log(result); // [1, 2, 3, 4, 5, 6]

// 📌 Объединение нескольких массивов
const arr3 = [7, 8, 9];
const combined1 = arr1.concat(arr2, arr3);
console.log(combined1); // [1, 2, 3, 4, 5, 6, 7, 8, 9]

// 📌 Добавление отдельных элементов в массив
const extendedArray = arr1.concat(10, 11, 12);
console.log(extendedArray); // [1, 2, 3, 10, 11, 12]

// 📌 Альтернативный способ "плоского" массива через `.reduce()`
const nestedArray = [1, [2, 3, 4], 5, [6]];
const flatArray1 = nestedArray.reduce((acc, elem) => acc.concat(elem), []);
console.log(flatArray1); // [1, 2, 3, 4, 5, 6]

// 📌 Использование `.flat()` (не поддерживается старыми браузерами)
const flatAlternative = nestedArray.flat();
console.log(flatAlternative); // [1, 2, 3, 4, 5, 6]

//===============================================================================================//
// 🔹 ⚠️ Важно помнить:
// ✅ `.concat()` **не изменяет оригинальный массив**.
// ✅ Можно комбинировать **как массивы, так и отдельные значения**.
// ✅ `.concat()` **не рекурсивен** — вложенные массивы остаются вложенными (используйте `.flat()` для полной раскрутки).

//===============================================================================================//
// 🎯 Итог:
// ✅ `.concat()` объединяет массивы и элементы.
// ✅ Создает **новый массив**, не изменяя исходный.
// ✅ `.reduce()` или `.flat()` могут помочь, если нужно "развернуть" вложенные массивы.



// 📌 Метод .slice()

//===============================================================================================//
// 🔹 Что делает .slice()
// Метод `.slice()` **возвращает новый массив**, содержащий часть элементов исходного массива.

// 📌 Синтаксис:
// array.slice(start, end);
    // start: Индекс начала выборки (включительно).
    // end (необязательно): Индекс конца выборки (НЕ включается в новый массив).

// 📌 Особенности:
// ✅ **Не изменяет оригинальный массив**, а создает новый.
// ✅ Если `end` не указан — копирует элементы до конца массива.
// ✅ Можно использовать для создания **копии массива** (`arr.slice()`).

//===============================================================================================//
// 🔹 Примеры использования

// 📌 Получение части массива
// const arrayNumber = [1, 2, 3, 4, 5, 6, 7, 8, 9];
// const slicedArr = arrayNumber.slice(3, 8);
// console.log(slicedArr); // [4, 5, 6, 7, 8]

// // 📌 Копирование всего массива
// const copiedArr = arrayNumber.slice();
// console.log(copiedArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9]

// 📌 Использование отрицательных индексов
// const lastThree = arrayNumber.slice(-3);
// console.log(lastThree); // [7, 8, 9]

// 📌 Удаление первого элемента
// const withoutFirst = arrayNumber.slice(1);
// console.log(withoutFirst); // [2, 3, 4, 5, 6, 7, 8, 9]

//===============================================================================================//
// 🔹 ⚠️ Важно помнить:
// ✅ `.slice()` **не изменяет оригинальный массив**.
// ✅ Если `start` больше длины массива, вернется **пустой массив**.
// ✅ Если `end` меньше `start`, тоже вернется **пустой массив**.

//===============================================================================================//
// 🎯 Итог:
// ✅ `.slice()` извлекает часть массива, **создавая новый**.
// ✅ **Можно использовать для копирования массива**.
// ✅ Поддерживает **отрицательные индексы** для удобного получения элементов с конца.



// 📌 Метод .splice()

//===============================================================================================//
// 🔹 Что делает .splice()
// Метод `.splice()` **изменяет оригинальный массив**, добавляя или удаляя элементы в указанном месте.

// 📌 Синтаксис:
// array.splice(start, deleteCount, item1, item2, ...);
    // start: Индекс, с которого начинать изменения.
    // deleteCount (необязательно): Количество удаляемых элементов.
    // item1, item2, ... (необязательно): Новые элементы для вставки.

// 📌 Особенности:
// ✅ **Меняет** оригинальный массив.
// ✅ Позволяет **удалять** или **добавлять** элементы.
// ✅ Если `deleteCount` **не указано**, удаляются все элементы до конца массива.

//===============================================================================================//
// 🔹 Примеры использования

// 📌 Удаление элементов из массива
const tasks = [
    'Проверить тесты',
    'Выполнить код-ревью',
    'Поработать',
    'Вкатиться в айтишку',
    'Приготовить еду',
    'Подготовить доклад',
    'Обновить бэклог'
];

tasks.splice(1, 4); // Удаляем 4 элемента, начиная с индекса 1
console.log(tasks);
// ['Проверить тесты', 'Подготовить доклад', 'Обновить бэклог']

// 📌 Добавление элементов в массив
const days = ['Понедельник', 'Вторник', 'Пятница'];
days.splice(2, 0, 'Среда', 'Четверг'); // Добавляем перед Пятницей
console.log(days);
// ['Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница']

// 📌 Замена элементов в массиве
const numbersArr1 = [1, 2, 3, 10, 20, 30];
numbersArr1.splice(3, 2, 4, 5); // Заменяем 10 и 20 на 4 и 5
console.log(numbersArr1);
// [1, 2, 3, 4, 5, 30]

//===============================================================================================//
// 🔹 ⚠️ Важно помнить:
// ✅ `.splice()` **меняет** оригинальный массив!
// ✅ Можно использовать `.slice()` если нужен **новый массив без изменений исходного**.
// ✅ Если `deleteCount` = `0`, элементы **только добавляются** без удаления.

//===============================================================================================//
// 🎯 Итог:
// ✅ `.splice()` **изменяет массив**, удаляя, добавляя или заменяя элементы.
// ✅ Хорошо подходит для **управления списками и массивами**.
// ✅ **Используйте осторожно**, если нужно сохранить оригинальный массив.



// 📌 Методы indexOf() и includes()

//===============================================================================================//
// 🔹 Что делают indexOf() и includes()
// `.indexOf()` **ищет элемент в массиве** и возвращает его индекс или `-1`, если элемента нет.
// `.includes()` **проверяет наличие элемента** в массиве и возвращает `true` или `false`.

// 📌 Синтаксис:
// array.indexOf(searchElement, fromIndex);
// array.includes(searchElement, fromIndex);
    // searchElement: Элемент, который ищем.
    // fromIndex (необязательно): Начальный индекс поиска.

// 📌 Особенности:
// ✅ `.indexOf()` **возвращает индекс** первого вхождения или `-1`, если элемента нет.
// ✅ `.includes()` **возвращает `true`**, если элемент найден, иначе `false`.
// ✅ `.indexOf()` используется для **поиска индекса**, `.includes()` – только для проверки наличия элемента.

//===============================================================================================//
// 🔹 Примеры использования

// 📌 Поиск индекса элемента в массиве
const names = ["Bob", "John", "Tom"];
console.log(names.indexOf("Tom")); // 2
console.log(names.indexOf("Alice")); // -1 (элемента нет)

// 📌 Проверка наличия элемента в массиве
console.log(names.includes("Tom")); // true
console.log(names.includes("Alice")); // false

// 📌 Использование `.indexOf()` для фильтрации списка
const allStudents = ["Ann", "Tom", "Bob", "Kate"];
const failedStudents = ["Tom", "Bob"];

const passedStudents1 = allStudents.filter(name => failedStudents.indexOf(name) === -1);
console.log(passedStudents1); // ["Ann", "Kate"]

// 📌 Альтернативный способ с `.includes()` (предпочтительный)
const passedStudents2 = allStudents.filter(name => !failedStudents.includes(name));
console.log(passedStudents2); // ["Ann", "Kate"]

//===============================================================================================//
// 🔹 ⚠️ Важно помнить:
// ✅ `.indexOf()` **ищет индекс**, но не подходит для булевой проверки (лучше `.includes()`).
// ✅ `.includes()` **работает быстрее** и удобнее для простых проверок наличия элемента.
// ✅ Если `fromIndex` указан, поиск начинается с этого индекса, а не с начала массива.

//===============================================================================================//
// 🎯 Итог:
// ✅ `.indexOf()` возвращает индекс первого вхождения или `-1`, если элемент отсутствует.
// ✅ `.includes()` просто проверяет, есть ли элемент в массиве (`true` или `false`).
// ✅ Для проверки наличия элемента удобнее использовать `.includes()`.



// 📌 Метод .map()

//===============================================================================================//
// 🔹 Что делает .map()
// Метод `.map()` **создает новый массив**, в котором каждый элемент — **результат вызова callback-функции**.

// 📌 Синтаксис:
// array.map(callback(element, index, array), thisArg);
    // element: Текущий элемент массива.
    // index (необязательно): Индекс текущего элемента.
    // array (необязательно): Сам массив.
    // thisArg (необязательно): Значение для `this` в callback-функции.

// 📌 Особенности:
// ✅ **Не изменяет оригинальный массив**.
// ✅ Всегда возвращает **новый массив** с преобразованными значениями.
// ✅ Идеально подходит для преобразования данных.

//===============================================================================================//
// 🔹 Примеры использования

// 📌 Умножение каждого элемента массива на 2
const numbers2 = [1, 2, 3, 4, 5];
const doubled1 = numbers2.map(num => num * 2);
console.log(doubled1); // [2, 4, 6, 8, 10]

// 📌 Преобразование массива имен в приветственные сообщения
const allStudents1 = ["Ann", "Tom", "Bob", "Kate"];
const failedStudents1 = ["Tom", "Bob"];

const getMessagesForPassedStudents = (allStudents, failedStudents) => {
    return allStudents
        .filter(name => !failedStudents.includes(name)) // Фильтрация студентов, которые сдали
        .map(name => `Hello, ${name}!`); // Добавление приветствия
};

console.log(getMessagesForPassedStudents(allStudents1, failedStudents1));
// ["Hello, Ann!", "Hello, Kate!"]

// 📌 Преобразование массива объектов в массив строк
const usersObj1 = [
    { name: "Alice", age: 25 },
    { name: "Bob", age: 30 },
    { name: "Charlie", age: 35 }
];

const userDescriptions = usersObj1.map(user => `${user.name} - ${user.age} лет`);
console.log(userDescriptions);
// ["Alice - 25 лет", "Bob - 30 лет", "Charlie - 35 лет"]

// 📌 Получение длины каждого слова в массиве
const words1 = ["apple", "banana", "kiwi", "pineapple"];
const wordLengths = words1.map(word => word.length);
console.log(wordLengths); // [5, 6, 4, 9]

//===============================================================================================//
// 🔹 ⚠️ Важно помнить:
// ✅ `.map()` **не изменяет оригинальный массив**.
// ✅ Всегда возвращает **новый массив**.
// ✅ Если callback-функция **неявно возвращает `undefined`**, итоговый массив тоже будет с `undefined`.

//===============================================================================================//
// 🎯 Итог:
// ✅ `.map()` **создает новый массив** с преобразованными элементами.
// ✅ Идеален для **изменения структуры массива**.
// ✅ Можно использовать `.filter()` перед `.map()`, чтобы работать только с нужными элементами.



