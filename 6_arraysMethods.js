// Методы работы с массивами

//===============================================================================================//

// Перебор элементов массива
// .forEach()

// Добавление/удаление элементов
// .push() *
// .pop() *
// .unshift() *
// .shift() *
// .splice() *
// .slice()
// .concat()

// Преобразование массива
// .map()
// .sort() *
// .reverse() *
// .join()
// .reduce()
// .flat()
// .flatMap()

// Поиск по массиву
// .indexOf()
// .lastIndexOf()
// .includes()
// .find()
// .findIndex()
// .filter()
// .some()
// .every()

// * - Изменяют исходный массив

// При использовании отдавать приоритет тем, которые не изм. исх. массив

//===============================================================================================//

// Нахождение чисел, кратные 3 с помощью цикла

// const getSpecialNumbers = numbers => {
//     let specialNumbers = []
//     for (let i = 0; i < numbers.length; i++) {
//         if (numbers[i] % 3 === 0) {
//             specialNumbers.push(numbers[i])
//         }
//     }
//     return specialNumbers
// }

// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(getSpecialNumbers(arr));

//===============================================================================================//

/* 
Метод .forEach() используется для выполнения функции один раз для каждого элемента массива. 
Он не изменяет оригинальный массив и не возвращает новое значение.
Метод forEach() автоматически встроен в любой массив.

array.forEach(callback(currentValue, index, array), thisArg);
    callback: Функция, которая будет выполнена для каждого элемента массива. Она принимает три аргумента:
        currentValue: Текущий обрабатываемый элемент массива.
        index (необязательно): Индекс текущего элемента.
        array (необязательно): Массив, по которому выполняется обход.
    thisArg (необязательно): Значение, используемое в качестве this при выполнении функции callback.
Особенности:
    Метод forEach не возвращает новое значение, он просто выполняет указанную функцию для каждого элемента массива.
    Нельзя прервать выполнение метода forEach с помощью break или return. 
    Если нужно прервать выполнение, лучше использовать цикл for или метод some.
*/ 

//===============================================================================================//

//Примеры:

// Нахождение чисел, кратные 3 с помощью метода forEach()

// const getSpecialNumbers = numbers => {
//     let specialNumbers = []

//     const checkIfSpecialNumber = num => {
//         if(num % 3 === 0) {
//             specialNumbers.push(num)
//         }
//     }

//     numbers.forEach(checkIfSpecialNumber)

//     return specialNumbers
// }

// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(getSpecialNumbers(arr));



// const getSpecialNumbers = numbers => {
//     let specialNumbers = []

//     numbers.forEach(num => {
//         if(num % 3 === 0) {
//             specialNumbers.push(num)
//         }
//     })

//     return specialNumbers
// }

// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(getSpecialNumbers(arr));

//===============================================================================================//

// Метод .filter()
/*
Метод массива .filter() позволяет получить новый массив, отфильтровав элементы с помощью переданной колбэк-функции. 
Колбэк-функция будет вызвана для каждого элемента массива и по результату функции примет решение включать этот элемент в 
новый массив или нет.
Аналогично методу .forEach(), методу .filter() необходимо передать аргументом функцию. 
Главное отличие — функция должна возвращать boolean, т. е. результатом должен быть true или false. 
Такие функции называют предикатами.

array.filter(callback(element, index, array), thisArg);
    callback: Функция, которая будет выполнена для каждого элемента массива. Она принимает три аргумента:
        element: Текущий обрабатываемый элемент массива.
        index (необязательно): Индекс текущего элемента.
        array (необязательно): Массив, по которому выполняется обход.
    thisArg (необязательно): Значение, используемое в качестве this при выполнении функции callback.


Функция, которую мы передаём в метод .filter(), принимает три параметра:
    item — элемент массива в текущей итерации;
    index — индекс текущего элемента;
    arr — сам массив, который мы перебираем.

Особенности
Метод filter возвращает новый массив, содержащий элементы, которые прошли проверку в функции callback.
Если ни один элемент не прошел проверку, метод filter вернет пустой массив.

*/

// const getSpecialNumbers = numbers => {
//     const result = numbers.filter(num => {
//         if(num % 3 === 0) {
//             return true
//         }
//         return false
//     })
//     return result
// }

// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(getSpecialNumbers(arr));


// const getSpecialNumbers = numbers => {
//     return numbers.filter(num => num % 3 === 0)
// }
// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(getSpecialNumbers(arr))


//===============================================================================================//

// Метод .sort()

/*
Метод sort() используется для сортировки элементов массива на месте и возвращает отсортированный массив. 
По умолчанию элементы сортируются как строки в порядке возрастания.

Метод имеет только один опциональный параметр — функцию-компаратор sort(compareFn).

В функцию-компаратор передаются два аргумента a и b. Результат сравнения возвращаемого значения из 
функции с 0 определяет порядок элементов:
    значение меньше 0 означает, что элемент a меньше, чем элемент b;
    значение больше 0 означает, что элемент a больше, чем элемент b;
    значение равно 0 означает, что элементы равны.
Все элементы массива со значением undefined после сортировки попадут в конец массива. 
Для этих элементов не будет вызываться функция compareFn().
*/

// const sortArray = numbers => {
//     // Создание коппии массива, чтобы не изменять исходный
//     // let copy = [...numbers]
//     let copy = numbers.slice()
//     copy.sort((a, b) => a - b)

//     return copy
// }

// const arr = [2, 4, 1, 5, 21, 18]
// console.log(sortArray(arr));

// console.log(arr);


//===============================================================================================//

// Метод .reduce()

/*
Метод массива reduce() позволяет превратить массив в любое другое значение с помощью переданной функции-колбэка и 
начального значения. Функция-колбэк будет вызвана для каждого элемента массива, и всегда должна возвращать результат.

Метод reduce() принимает два параметра: функцию-колбэк и начальное значение для аккумулятора.

Сама функция-колбэк может принимать четыре параметра:
    acc — текущее значение аккумулятора;
    item — элемент массива в текущей итерации;
    index — индекс текущего элемента;
    arr — сам массив, который мы перебираем.

*/ 

// [1, 2, 3, 4, 5] сложение всех чисел в масссиве
// const arr = [1, 2, 3, 4, 5]
// const sum = arr.reduce((acc, num) => acc + num, 0)
// console.log(sum);

/*
1: 0, 1 => 1
2: 1, 2 => 3
3: 3, 3 => 6
4: 6, 4 => 10
5: 10, 5 => 15
*/ 

//===============================================================================================//

// Метод concat()

// Метод concat() возвращает новый массив, содержащий все элементы исходного массива.
// [1, [2, 3, 4], 5, [6]] => [1, 2, 3, 4, 5, 6]

// const flatArray = arr => 
//     arr.reduce((acc, elem) => acc.concat(elem), [])

// const array = [1, [2, 3, 4], 5, [6]]
// console.log(flatArray(array));

// Не поддерживается во многих браузерах
// const array = [1, [2, 3, 4], 5, [6]].flat()
// console.log(array);

//===============================================================================================//

// Метод slice()

// Метод slice() возвращает новый массив, содержащий часть элементов исходного массива
// const arr = [1, 2, 3, 4, 5, 6, 7, 8 ,9].slice(3, 8)
// console.log(arr)

//===============================================================================================//

// Метод splice()

// Метод splice() изменяет содержимое массива, добавляя или удаляя элементы в указанном месте массива.

// const tasks = [
//     'Проверить тесты',
//     'Выполнить код-ревью',
//     'Поработать',
//     'Вкатиться в айтишку',
//     'Приготовить еду',
//     'Подготовить доклад',
//     'Обновить бэклог'
// ]
//   tasks.splice(1, 4)
  
//   console.log(tasks)

//===============================================================================================//

// Метод indexOf() и includes()

// Метод indexOf() возвращает индекс первого вхождения элемента в массив.
// Метод includes() возвращает true, если элемент есть в массиве, и false, если элемента нет в массиве.

// indexOf() Возвращает индекс элемента. В противном случае -1.
// includes() Проверяет, входит ли элемент в массив или нет

// const arr = ['Bob', 'John', 'Tom'].indexOf('Tom')
// console.log(arr)


// const getMessagesForPassedStudents = (allStudents, failedStudents) => {
//     const passedStudents = allStudents
//         // .filter(name => !(failedStudents.indexOf(name) !== -1))
//         // .filter(name => failedStudents.indexOf(name) === -1)
//     return passedStudents
// }

// const allStudents = ['Ann', 'Tom', 'Bob', 'Kate']
// const failedStudents = ['Tom', 'Bob']

// console.log(getMessagesForPassedStudents(allStudents, failedStudents))


// const getMessagesForPassedStudents = (allStudents, failedStudents) => {
//     const passedStudents = allStudents
//         .filter(name => !failedStudents.includes(name))
//     return passedStudents
// }

// const allStudents = ['Ann', 'Tom', 'Bob', 'Kate']
// const failedStudents = ['Tom', 'Bob']

// console.log(getMessagesForPassedStudents(allStudents, failedStudents))

//===============================================================================================//

// Метод map()

// Применяется к каждому эл. массива и возвращает новый массив(Возвращает новый массив, в котором каждый элемент — результат вызова callback-функции для каждого).

// const getMessagesForPassedStudents = (allStudents, failedStudents) => {
//     return allStudents
//         .filter(name => !failedStudents.includes(name))
//         .map(name => `Hello, ${name}!`)
// }

// const allStudents = ['Ann', 'Tom', 'Bob', 'Kate']
// const failedStudents = ['Tom', 'Bob']

// console.log(getMessagesForPassedStudents(allStudents, failedStudents))

//===============================================================================================//

















 
































































































// 📌 Методы массивов в JavaScript

//===============================================================================================//
// 🔹 Перебор элементов массива
const arr = [1, 2, 3];

arr.forEach(num => console.log(num)); // 1, 2, 3 (перебор элементов)


// 🔹 Добавление/удаление элементов
const numbers = [1, 2, 3];

numbers.push(4);  // [1, 2, 3, 4] (добавляет в конец) *
numbers.pop();    // [1, 2, 3] (удаляет последний) *
numbers.unshift(0); // [0, 1, 2, 3] (добавляет в начало) *
numbers.shift();  // [1, 2, 3] (удаляет первый) *
numbers.splice(1, 1, 99); // [1, 99, 3] (удаляет и добавляет по индексу) *
const sliced = numbers.slice(1, 2); // [99] (копирует часть массива)
const combined = numbers.concat([4, 5]); // [1, 99, 3, 4, 5] (объединяет массивы)


// 🔹 Преобразование массива
const doubled = numbers.map(num => num * 2); // [2, 198, 6] (преобразует элементы)
const sorted = [3, 1, 2].sort(); // [1, 2, 3] (сортирует) *
const reversed = [1, 2, 3].reverse(); // [3, 2, 1] (переворачивает) *
const joined = numbers.join('-'); // "1-99-3" (объединяет в строку)
const sum = numbers.reduce((acc, num) => acc + num, 0); // 103 (сворачивает массив)
const flatArray = [1, [2, 3], [4, 5]].flat(); // [1, 2, 3, 4, 5] (разглаживает вложенные массивы)


// 🔹 Поиск по массиву
const hasTwo = numbers.includes(2); // false (проверяет наличие)
const found = numbers.find(num => num > 1); // 99 (возвращает первый найденный)
const filtered = numbers.filter(num => num > 1); // [99, 3] (фильтрует)
const someGreaterThanTwo = numbers.some(num => num > 2); // true (хотя бы один)
const allGreaterThanZero = numbers.every(num => num > 0); // true (все соответствуют)

//===============================================================================================//
// 🎯 Итог:
// ✅ Методы массивов позволяют изменять, искать и преобразовывать данные.
// ✅ Методы с `*` изменяют исходный массив, поэтому их следует использовать осторожно.
// ✅ Для безопасного изменения массива лучше использовать `.map()`, `.filter()`, `.slice()`, `.concat()`.



// 📌 Нахождение чисел, кратных 3 с помощью цикла

//===============================================================================================//
// 🔹 Классический способ (for)
const getSpecialNumbers = numbers => {
    let specialNumbers = [];
    for (let i = 0; i < numbers.length; i++) {
        if (numbers[i] % 3 === 0) {
            specialNumbers.push(numbers[i]);
        }
    }
    return specialNumbers;
};

let array = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(getSpecialNumbers(array)); // [3, 6, 9]

//===============================================================================================//
// 🔹 Альтернативный способ (forEach)
const getSpecialNumbersForEach = numbers => {
    let specialNumbers = [];
    numbers.forEach(num => {
        if (num % 3 === 0) {
            specialNumbers.push(num);
        }
    });
    return specialNumbers;
};

console.log(getSpecialNumbersForEach(array)); // [3, 6, 9]

//===============================================================================================//
// 🔹 Оптимизированный способ (filter)
const getSpecialNumbersFilter = numbers => numbers.filter(num => num % 3 === 0);

console.log(getSpecialNumbersFilter(array)); // [3, 6, 9]

//===============================================================================================//
// 🎯 Итог:
// ✅ `for` – классический способ, удобен для сложных операций.
// ✅ `forEach` – более читаемый, но требует внешнего массива для хранения результатов.
// ✅ `filter` – самый лаконичный и удобный способ для нахождения элементов по условию.



/* 
📌 Метод .forEach() используется для выполнения функции один раз для каждого элемента массива. 
Он не изменяет оригинальный массив и не возвращает новое значение.
Метод forEach() автоматически встроен в любой массив.

array.forEach(callback(currentValue, index, array), thisArg);
    🔹 callback: Функция, которая будет выполнена для каждого элемента массива. Она принимает три аргумента:
        - currentValue: Текущий обрабатываемый элемент массива.
        - index (необязательно): Индекс текущего элемента.
        - array (необязательно): Массив, по которому выполняется обход.
    🔹 thisArg (необязательно): Значение, используемое в качестве this при выполнении функции callback.

📌 Особенности:
    ✅ Метод forEach не возвращает новое значение, он просто выполняет указанную функцию для каждого элемента массива.
    ✅ Нельзя прервать выполнение метода forEach с помощью break или return. 
    ✅ Если нужно прервать выполнение, лучше использовать цикл for или метод some.
*/

//===============================================================================================//
// 🔹 Пример 1: Вывод элементов массива
const numbersArr = [1, 2, 3, 4, 5];

numbersArr.forEach(num => console.log(num)); 
// 1
// 2
// 3
// 4
// 5

//===============================================================================================//
// 🔹 Пример 2: Использование индекса
numbersArr.forEach((num, index) => console.log(`Индекс ${index}: значение ${num}`));
// Индекс 0: значение 1
// Индекс 1: значение 2
// Индекс 2: значение 3
// Индекс 3: значение 4
// Индекс 4: значение 5

//===============================================================================================//
// 🔹 Пример 3: Изменение элементов массива (не рекомендуется)
numbersArr.forEach((num, index, arr) => arr[index] = num * 2);
console.log(numbersArr); // [2, 4, 6, 8, 10]

//===============================================================================================//
// 🔹 Пример 4: Использование thisArg
const obj = {
    multiplier: 3,
    multiplyNumbers(arr) {
        arr.forEach(function(num) {
            console.log(num * this.multiplier);
        }, this); // Передаем thisArg
    }
};

obj.multiplyNumbers(numbersArr);
// 6
// 12
// 18
// 24
// 30

//===============================================================================================//
// 🎯 Итог:
// ✅ Метод .forEach() удобен для выполнения действий над каждым элементом массива.
// ✅ Не изменяет оригинальный массив (если не делать этого вручную).
// ✅ Не возвращает новое значение, поэтому для преобразования массива лучше использовать .map().



