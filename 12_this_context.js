// Контекст выполнения

// Объект пользователя
// let user = {
//     name: "John",
//     age: 30,
//     // короткая запись метода объекта
//     sayHi() {
//         console.log('Hello')
//     }
// }

// user.sayHi = function() {
//     console.log(`Hello`)
// }

// user.sayHi()

//===============================================================================================//

// Ключевое слово «this» в методах

/* 
    Как правило, методу объекта обычно требуется доступ к информации, хранящейся в объекте, для 
    выполнения своей работы.

    Например, коду внутри user.sayHi() может потребоваться имя пользователя, которое хранится в 
    объекте user.

    Для доступа к информации внутри объекта метод может использовать ключевое слово this.

    Значение this – это объект «перед точкой», который используется для вызова метода.
*/

// let user = {
//     name: "John",
//     age: 30,
//     sayHi() {
//       // "this" - это "текущий объект".
//       console.log(this.name);
//     }
// };
  
// user.sayHi(); // John

/* 
    Технически также возможно получить доступ к объекту без ключевого слова this, обратившись к 
    нему через внешнюю переменную (в которой хранится ссылка на этот объект):

    let user = {
    name: "John",
    age: 30,

    sayHi() {
        alert(user.name); // "user" вместо "this"
    }

    };
    …Но такой код ненадёжен. Если мы решим скопировать ссылку на объект user в другую переменную, например, admin = user, 
    и перезапишем переменную user чем-то другим, тогда будет осуществлён доступ к неправильному объекту при вызове метода из admin.

    Это показано ниже:

    let user = {
    name: "John",
    age: 30,

    sayHi() {
        alert( user.name ); // приведёт к ошибке
    }

    };

    let admin = user;
    user = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.

    admin.sayHi(); // TypeError: Cannot read property 'name' of null
    Если бы мы использовали this.name вместо user.name внутри alert, тогда этот код бы сработал.
*/

