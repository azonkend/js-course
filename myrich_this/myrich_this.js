'use strict'

// js - встраиваемый скриптовый язык, сам по себе он не существует. Он встроен либо в браузер, либо в ноду, v8, либо в 
// окружение чайника
// у него есть свой набор функций, которые определены спецификацией языка, и набор сторонних API, который позволяет языку их вызывать.
// Любое API Может назначить this как ему вздумается.

//===============================================================================================//

/* 
    This в js - это не контекст

    This - это ключевое слово(выражение), которое по своему поведению максимально близко к
    поведению идентификатора(названия переменных - это имена идентификаторов).(Название идентификатора с некотормым
    особенным поведением).

    Окружения существуют только вокруг того кода, который сейчас непосредственно выполняется. Каждая функция, код, который начинает работать,
    вокруг него создаётся своё окружение, в котором js run time хранит всю информацию о выполнении этого кода.

    Скрипт и модуль - это два термина спецификации js, которые описывают разные способы выполнения кода.
    Script - тот код, который запускается по умолчанию.
    Module - это запуск того же самого кода с определённым параметром, который называется "Модуль". (Когда мы
    используем import, мы запускаем код в рамках окружения модуль. Мы можем запустить run time, чтобы он выполнялся сразу в окружении
    модуль)

    Базово наш код запускается в окружении Script.
*/ 

// По большей части всё зависит от того, как и какая функция запускается

//===============================================================================================//

// this и Global Environment

// В node.js выведет - {}, в v8(обычное выполнение скрипта) - [object global]
// в v8 c --module(запуск в окружении, если бы это был модуль) - undefined

// console.log('this is: ', this)

// this в v8 и в браузере устанавливается в глобальный объект по умолчанию в соотв. со спецификацией. 
// HOST может менять значение this

//===============================================================================================//

// Function Environment
// Normal Function это функция, которая не Arrow Function
 
// function doLogThis() {
//     var doArrowThing = (
//         () => console.log('this is ', this)
//     )
//     doArrowThing()
// }
// doLogThis()

// Вызов норм функции изменяет this(this начинает быть связано с каким-то значением(стрелочная это не делает))
// Всгда имеет минимум 1 аргумент - this. Он всегда связывается с каким-то значением при вызове функции.
// Если аргумент this не задан, то он всегда равен undefined

//===============================================================================================//

// Arrow Function Environment
// Cтрелочная функция не меняет this

// this и вызов функции

// Если функция вызвана с помощью этих 2 методов и 3 метода пересоздания этой функции с привязкой this.
// this заданный с помощью этих методов всегда будет таким и переопределить его нельзя.

//===============================================================================================//

// this call, apply и bind
// function doLogThis() {
//     console.log('this is: ', this)
// }

// var thisArg = { name: 'thisArg'}
// doLogThis.call( thisArg )
// doLogThis.apply( thisArg )
// doLogThis.bind( thisArg )()

// this = значегнию из метода

//===============================================================================================//

// this и new

// new - выражение, которое вызыввает любую функцию, за исключением стрелочных.
// вызывается функция и this связывается с пустым объектом
// function doLogThis() {
//     console.log('this is: ', this) // this is: doLogThis {}
// }
// new doLogThis()
// new doLogThis

//===============================================================================================//

// this и дот нотация
/* 
    Дот нотацией(dot notation) в js, называют синтаксис, когда два идентификатора разделены между собой
    точкой(dot). Например: theObj.theProperty
    Его полным аналогом является синтаксис: theObj['theProperty']

    Вызов функции в dot нотации выглядит следующим образом:
    theObj.doThing()
    theObj.['doThing']()
*/

// function doLogThis() {
//     console.log('this is: ', this)
// }
// doLogThis()

// function doLogThis() {
//     console.log('this is: ', this)
// }

// const theObj = {
//     name: 'Murych'
// }
// // this равняется тому идентификатору, который стоит перед точкой
// theObj.doLogThis = doLogThis // связвываем с ранее определённой функцией
// theObj.doLogThis() // это связывает this c theObj

// Пример наоборот

// const theObj = {
//     name: 'Murych',
//     doLogThis: function() {
//         console.log('this is: ', this)
//     }
// }
// theObj.doLogThis()
// var doLogThisGlobal = theObj.doLogThis
// doLogThisGlobal()

// Пример наоборот - 2

// const theObj = {
//     name: 'Murych',
//     doLogThis: function() {
//         console.log('this is: ', this)
//     } 
// }

// setTimeout( theObj.doLogThis, 1 ) // v8 выведет undefined

// Пример наоборот - 3

// const theObj = {
//     name: 'Murych',
//     doLogThis: function() {
//         console.log('this is: ', this)
//     }
// }

// var doLogThis = theObj.doLogThis
// setTimeout( doLogThis, 1)

//===============================================================================================//

// API call
// *в браузере
// function doClick() {
//     console.log('Click: ', this)
// }

// document.body.addEventListener('click', doClick)
// document.body.addEventListener('click', doClick.bind({'yo': 'yo'})) // Click: {yo: 'yo'}

//===============================================================================================//

/* 
    Для того чтобы понять, чему равен this, нужно всегда смотреть на то, где вызывается функция, внутри
    которой мы хотим узнать, чему равен this. Если мы находимся НЕ внутри функции, то мы находимся либо в
    скрипте, либо в модуле. Если в модуле, то это undefined, если в скрипте, то читаем спецификацию по 
    HOST-системе, которая может установить this, как ей хочется. 

    Если мы оказались внутри функции, то первое, что нужно посмотреть стрелочная это функция или нет и как 
    эта функция была вызвана. Если функция НЕ стрелочная, то тогда смотрим, как она вызывалась. Если
    стрелочная - то смотрим на родительское окружение.

    call, apply и bind - явно задают значение this(this всегда будет равен тому, как он назначен внутри
    этих методов)

    new - ключевое слово, которое вызывает функцию, внутри которой оно связывает this c пустым объектом {}

    Если функция вызывается дот-нотацией, то this всегда равен тому, что перед точкой

    У любой нормальной функции есть this 


*/

// function doThing() {
//     console.log(this)
// }

// var theObj = {'name': 'Yo'}

// theObj.ddd = doThing
// theObj.ddd()

/* 
    JavaScript – это удивительный мир, в котором ключевое слово this занимает центральное место во множестве 
    сценариев, начиная с глобальной области, где this может указывать на глобальный объект или даже быть 
    пустым в модульном окружении, и заканчивая экзотическими случаями вызова функций, 
    когда вы используете call, apply или bind, чтобы специально зафиксировать контекст исполнения. 
    Представьте, что в самом начале вы знакомитесь с идеей, что this – это способ узнать, кто именно совершает 
    действие в конкретный момент: в нестрогом режиме при запуске скрипта через тег script в браузере this 
    укажет на window, но если вы переключитесь в строгий режим, то this станет undefined, словно вы вдруг 
    потеряли свой ID-карточку в условном клубе. Когда вы исследуете function environment, то есть среду, в 
    которой обрабатываются локальные переменные и контексты выполнения, вы замечаете, что обычные функции 
    (normal/ordinary function) умеют самостоятельно формировать свой this, опираясь на то, как мы их вызываем. 
    Если мы создаем объект с методом и вызываем метод через точку, то this ссылается на этот самый объект, 
    а когда мы выдираем метод и вызываем отдельно, контекст может потеряться и превратиться в глобальный или 
    undefined в строгом режиме. Со стрелочными функциями все еще запутаннее: у них нет собственного this, 
    они унаследуют контекст, актуальный в лексическом окружении, где они были объявлены, что особенно чувствуется, 
    когда вы создаете колбэки внутри методов. Дальше встречаются scenarios, когда вы создаете экземпляр с 
    помощью new: тогда this внутри конструктора будет указывать на только что созданный объект. 
    Дот нотация – это когда вы пишете something.method, и именно этот объект становится владельцем метода и 
    задает this, но если вы проведете несколько цепочек, вроде obj1.obj2.obj3.method(), нужно понимать, 
    что метод в конце цепочки привязан к тому объекту, на котором непосредственно вызывается. 
    Пример с внешним API может показаться еще более сложным, особенно когда вы вызываете функции, 
    предоставленные другими библиотеками, потому что правила или подстановка контекста там могут отличаться. 
    В качестве итога всего, что выше, хотелось бы подытожить – понимание того, что this в JavaScript зависит от 
    способа вызова функции и от того, на каком уровне (глобальный скрипт или модуль) вы находитесь, 
    позволяет глубже проникнуть в саму суть языка и избежать ситуаций, когда незнание вызывает недоумение и 
    насмешки: ведь нередко бывает, что кто-то ожидает одного значения this, а получает совершенно другое. 
    По словам из книжки по JavaScript, этот момент часто недооценивают новички, которые еще не познакомились с 
    особенностями non strict mode, где правила работы с this могут заметно отличаться. 
    Более того, примеры со стрелочными функциями наглядно демонстрируют, как неподготовленность к 
    лексическому this способна приводить к ошибкам, особенно если вы пробуете связать этот this с примитивами 
    вроде строк или чисел, которые при приведении типов превращаются в объекты обертки. 
    И как итог можно сказать – если вы полностью понимаете механику работы this, то ваш код перестает быть 
    набором случайных фокусов, а становится продуманной программной архитектурой, где ни одна запятая или 
    скобка не выбивает магию из рук разработчика, и это позволит вам не только решать задачки про this, 
    но и в полной мере наслаждаться мощью и гибкостью JavaScript.




    Представьте, что JavaScript это большая игровая площадка, где у каждого объекта и функции есть своя роль и 
    место, а ключевое слово this это как волшебная палочка, указывающая, кто сейчас главный или участник 
    действия при выполнении кода. Для ребёнка, который только что впервые услышал про программирование, 
    можно сказать, что this это я внутри функции: когда функция что-то делает, this объясняет, кто именно 
    совершает действие. Но чем глубже мы погружаемся, тем интереснее становится: в глобальной области видимости 
    (особенно в нестрогом режиме) this указывает на глобальный объект, а в строгом режиме 'use strict' 
    он вовсе становится undefined, так как строгие правила лишают нас магии автоподстановки. 
    Когда мы используем методы внутри объектов, this привязывается к самому объекту, а если этот метод потом 
    оторвать и вызвать отдельно, контекст this может неожиданно измениться. Ещё более хитрым случаем является 
    привязывание контекста при помощи bind(), call() или apply(), которые насильно «заставляют» функцию считать 
    каким-то конкретным объектом свое this. Если добавить в уравнение стрелочные функции, мы обнаружим, 
    что у них собственного this как бы нет, и они захватывают лексический контекст this из области, 
    в которой были объявлены, а это уже подсвечивает важные концепции про Lexical Environment и 
    Execution Context, о которых упоминают в спецификации ECMAScript. Чем дальше мы идём, тем глубже осознаём, 
    что this на самом деле это не просто ключевое слово, а целая система правил, регулирующих, 
    куда именно указывает переменная окружения. Спецификация описывает это как связывание this 
    в начале вызова функции и определение её окружения в рамках так называемого 
    ECMAScript Execution Context Stack. Для фреймворков и библиотек это безумно важно, потому что неправильная 
    работа с this способна сломать логику приложения или вызвать непредсказуемые ошибки. 
    Но не бойтесь: осознание того, как работают правила привязки (implicit, explicit и lexical binding), 
    прочное понимание строгого режима и контекстов исполнения, а также умение использовать стрелочные 
    функции там, где важен лексический this, со временем открывают невероятные творческие 
    возможности в JavaScript. Ведь когда вы понимаете кто такой this, вы лучше чувствуете, 
    как орchestrate логику кода, и начинаете мыслить, как настоящий JS-инженер, буквально дирижируя 
    маленьким оркестром объектов, функций и контекстов, и это придаёт мотивации копать ещё глубже в тайны 
    спецификации, осваивать новые подходы и создавать элегантные решения!
*/